三种数字表示

- 无符号：基于传统的二进制表示法，表示大于等于零的数
- 补码：表示有符号的整数
- 浮点数：实数的科学计数法以2为基数的版本

计算机用有限数量的位来对一个数字编码，当结果太大不能表示时，就会发生**溢出**

整数运算范围小但精确，浮点数运算范围大但时近似的

# 信息储存

大多计算机使用8位的块，或者叫字节，作为最小的可寻址的内存单位，而不是单独访问内存中单独的位。内存中的每一个字节都由唯一的数字来标识，称为它的地址，所有可能的地址集合称为虚拟地址空间。虚拟地址空间只是一个展现给机器级程序的概念性映像。

## 十六进制

C语言中，常常用 0x 0X 来表示后面的数是十六进制的，这些数可以大写，也可以小写。

## 字数据大小

每台计算机都有一个字长，表明指针数据的字长大小

## 寻址和字节顺序

对象的地址是什么，在内存中如何排序这些字节。大多数机器上，多字节对象都被储存为连续的字节序列，对象的地址为使用字节中的最小的地址。

最高有效位在前，称为**大端法；**最高有效位在后，称为**小端法**

两端之争一直存在，现在的CPU大多数都支持双端，但操作系统可能只支持一端，很多都是小端法。

在通过网络传输二进制数据时，某一端的表示法可能存在问题，这就需要网络应用程序遵守已经建立的关于字节顺序的规则。

### 表示字符串

C语言中字符串被编码为一个以 null 字符结尾的数组，每个字符由标准都由某个标准码来表示，最常见的是ASCII 编码

### 表示代码

从机器角度来看，程序只是字节序列，没有关于原程序的任何信息

## 布尔代数简介

位向量运算可以定义为参数的每个对应元素之间的运算

位向量的另一个应用是可以表示有限集合

## C语言中的位级运算

NOT、AND、OR、EO

~、&、|、^

确定一个位级表达式的结果的最好的办法，就是将十六进制的参数扩展成二进制并执行二进制运算，然后再转换为十六进制。

## C语言中的逻辑运算

逻辑运算与位级运算不同，逻辑运算认为所有非零的数都为TRUE。

逻辑运算如果能在第一个参数确定表达式的结果，就不会对第二个参数求值

## C语言中的移位运算

左移：x<<k，丢弃最高的 k 位，并在右边补 k 个零。

右移

- 逻辑右移：在左端补 k 个0
- 算数右移：在左端补 k 个最高有效位的值

几乎所有的机器对于有符号数使用算术右移，对于无符号数使用逻辑右移。

# 整数表示

![](https://cdn.jsdelivr.net/gh/Jerrywang959/mypicchuang@master/img/1618984410272-1618984410260.png)

## 整数数据类型

四种数据类型：char, int, short, long

只有long 的范围与机器相关

### 无符号数的编码

$$B2U_\omega (\overrightarrow a)\doteq \sum_{i=0}^{\omega-1} x_i2^i$$

无符号数的编码的唯一性：函数 $B2U_\omega$是一个双射

## 补码编码

$$B2T_\omega(\overrightarrow x)\doteq-x_{\omega-1}2^{\omega-1} + \sum_{i=0}^{\omega-2}x_i2^i$$

最高有效位$x_{\omega-1}$称为符号位。

补码编码的唯一性：函数 $B2T_\omega$ 是一个双射

## 有符号数和无符号数之间的转换

保持位模式不变，强制转换。

### 补码数转为无符号数

对于满足 $TMin_\omega\le x\le TMax_\omega$ 的 $x$，有

$$T2U(x)=  \begin{cases} \ \ x+2^\omega, \quad x<0 \\  \ \ x, \qquad x\ge 0 \end{cases}$$

### 无符号数转为补码数

对于满足 $0\le u\le UMax_\omega$ 的 $u$ 有

$$U2T(u)=\begin{cases} u,\quad u\le TMax_\omega \\ u-2^\omega, \quad u>TMax_\omega\end{cases}$$

## C语言中的有符号数和无符号数

虽然没有强制申明，但是大多数默认补码，加上后缀字符 $u$ ，才认为是无符号的

## 扩展一个数字的位表示

无符号数的零扩展

简单地在表示的开头添加0，即可将无符号数转化为一个更大的数据类型

补码数的符号扩展

在左侧添加一定数量的最高有效位的值

## 截断数字

**截断无符号数**

直接去掉左边的几位

**截断补码数值**

没看懂......

## 有符号和无符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为，这就导致了程序错误并很难被发现。

# 整数运算

## 无符号加法

对于满足$0\le x,y\le 2^w$的$x,y$有

$$x+{}_\omega^u y=\begin{cases}x+y,\quad x+y<x^\omega \\ x+y-2^\omega,\quad 2^\omega \le x+y\le x^{\omega+1}\end{cases}$$

溢出指的是完整的整数结果不能放到数据类型的字长限制中去

## 补码加法

对于满足$-2 ^{\omega-1}\le x,y\le 2^{\omega}-1$的整数  $x$ 和 $y$，有

$$x+^t_\omega y=\begin{cases}x+y-2^\omega , \quad 2^{\omega-1}\le x+y \\ x+y,\quad -2^{\omega-1}\le x+y< x^{\omega-1} \\ x+y+2^\omega ,\quad x+y<-2^{\omega-1}\end{cases}$$

和过大时会正溢出，和过小时会负溢出

## 补码的非

对于满足 $TMin_\omega\le x \le TMax_\omega$ 的 $x$，其补码的非$-^t_\omega x$由下式给出

$$-_\omega^tx=\begin{cases}TMin_\omega,\quad x=TMin_\omega \\ -x,\quad x>TMin_\omega \end{cases}$$

## 无符号乘法

对于满足 $0\le x,y\le UMax_\omega$ 的$x$和$y$，有

$$x\times _\omega^u y=(x\cdot y)\mod 2^\omega$$

## 补码乘法

对于满足$TMin_\omega \le x , y\le TMax_\omega$ 的$x$，$y$有：

$$x\times _\omega^ty=U2T((x\cdot y)\mod 2^\omega )$$

## 乘以常数

乘以2的幂相当于直接在位的右边添对应个数的零

## 除法

除以2的幂可以用移位运算来实现(右移)，无符号和补码数分别使用逻辑移位和算数移位来达到目的。

**无符号除法**

$C$变量$x$和$k$有符号数值$x$和$k$，且$0\le k <\omega$，则$C$表达式$x>>k$产生数值$\left\lfloor x / 2^{k}\right\rfloor$

**除以2的幂的补码除法，向下舍入**

$C$变量$x$和$k$分别有补码值$x$和无符号数值$k$，且$0\le k<\omega$，则当执行算数位移时，$C$表达式$x>>k$产生数值$\left\lfloor x / 2^{k}\right\rfloor$

**除以2的幂的补码除法，向上舍入**

$C$变量$x$和$k$分别有补码值$x$和无符号数值$k$，且$0\le k<\omega$，则当执行算数位移时，$C$表达式$(x+(1<<k)-1)>>k$产生数值$\left\lfloor x / 2^{k}\right\rfloor$

计算机执行的“整数”运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围,结果运算可能溢出。

# 浮点数

浮点数表示对形如$V=x\times 2^y$的有理数进行编码

## 二进制小数

考虑一个形如$b_m,b_{m-1},\cdots,b_1,b_0,\cdots,b_{-n-1}b_{-n}$的表示法，每个都是二进制数字，称为位。这种方法表示的数$b$定义如下

$$b=\sum_{i=-n}^m2^i\times b_i$$

## IEEE浮点表示

用 $V=(-1)^s\times M\times 2^E$ 的形式来表示一个数

- 符号：$s$决定是正数还是负数
- 尾数：$M$是一个二进制小数，它的范围是$1 \sim 2-\epsilon$   ，或$0\sim 1-\epsilon$
- 阶码：$E$的作用是对浮点数加权，这个权重是 2 的$E$次幂

将浮点数的位表示化为三个字段，分别对这些值进行编码

- 一个单独的符号位$s$直接编码符号$s$
- $k$位的阶码字段$exp=e_{k-1}\cdots e_1e_0$编码阶段$E$
- $n$位小数字段$frac=f_{n-1}\cdots f_1f_0$编码尾数$M$

单精度(float)和双精度(double)分别为(1,8,23), (1,11,52)

### 浮点数范围的四种情况

**规格数**

最常见的情况，阶码不全为0或不全为1：

阶码字段表示为以偏置形式表示的有符号整数。阶码的值是$E=e-Bias$，$e$是无符号数，$Bias$为$2^{k-1}-1$

**非规格化的值**

阶码域全为0时，表示的是非规格化的数。阶码数是$E=1-Bias$，尾数$M=f$，也就是小数的字段、不包含隐含的开头的1

非规格化提供了一种表示0的方法，也可以表示非常接近0的数

**特殊值**

阶码全为1时。小数域全为0时，得到的值表示无穷，表示溢出的结果。小数域非零时，表示"NaN"(Not a Number)。这算是一种强行的规定，因为其他的数都被表示完了。

![](https://cdn.jsdelivr.net/gh/Jerrywang959/mypicchuang@master/img/1618984443536-1618984443525.png)

## 舍入

浮点数只能近似的表示实数运算，因此需要规定舍入方式，常见的有

向偶数舍入、向零舍入、向下舍入、向上舍入

偶数舍入感觉起来可以避免统计误差，因为它有50%的概率向上，50%的概率向下

