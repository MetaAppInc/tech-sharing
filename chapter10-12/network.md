# 网络编程

----------------------

## 一、客户端 —— 服务器编程模型

每个网络应用都是基于客户端——服务器模型的。一个应用是由一个服务器进程和一个或多个客户端组成的。服务器管理某些资源，并通过操作这些资源对客户端提供某种服务。    

客户端 —— 服务器模型中基本操作是事务。一个事务由以下四步组成：

1. 当客户端需要服务时，会向服务器发送一个请求，即发起一个事务。

2. 服务器收到请求后处理该请求，并以适当的方式操作它的资源。

3. 服务器给客户端发送一个响应，并等待下次请求。

4. 客户端收到响应并处理它。

一台主机可以可以同时运行许多不同的客户端和服务器，而且一个客户端和服务器的事务可以在同一台或是不同的主机上。

## 二、网络

客户端和服务器通常运行在不同的主机上，它们主要靠计算机网络来进行通信。对于主机而言，网络也是一种 I/O 设备，是数据源和数据接受方。从网络上接收到的数据通过 DMA[^DMA] 从适配器经由 I/O 和内存总线复制到内存。

### 1. 网络组成

##### 以太网

物理上而言，网络是一个按照地理远近组成的层次系统。最低层是 `LAN`（局域网），目前最流行的局域网技术是 `Ethernet` （以太网）。         

一个以太网段包括一些电缆和集线器。电缆的一段连接主机，另一端连接至集线器的一个端口上。集线器不加分辨的将从一个端口上收到的每个位复制到其他端口上， 所以每台主机都能看到每个位。   

每个以太网适配器都有一个全球唯一的 48 位地址，每个主机可以发送一段帧至其他主机。任何主机都能看到这个帧，但只有目的主机能实际读到它。

##### 桥接以太网

通过电缆和网桥，多个以太网可以组成更大的局域网，称作“桥接以太网”。一些电缆连接网桥和网桥，另一些连接网桥和集线器。网桥使用算法来更有效的利用带宽：它们随时间自动学习哪个主机可以通过哪个端口可达，然后只有在必要时才会有选择性的将帧从一个端口复制到另一个端口。

* 向同网段的主机发送帧，到达网桥的输入端口，会被直接丢弃，以解决其他网段的带宽。

* 向不同网段的主机发送帧，网桥只会向目的主机所在的网桥发送帧。

##### 路由器

在层次的更高级别中，多个不兼容的局域网可以通过路由器这种特殊计算机连接起来，组成 `internet` （互联网络）。每台路由器对于它所连接到的每个网络都有一个适配器（端口）。

### 2. 网络数据传输

互联网至关重要的特性是，它能由采用完全不同和不兼容的技术的各种局域网和广域网组成。在每台主机和路由器上运行的协议软件，消除了不同网络间的差异。这种协议控制主机和路由器如何协同工作来实现数据传输。这样的协议必须提供两种基本能力：

1. 命名机制。不同局域网有不同和不兼容的方式为主机分配地址。互联网络协议通过定义一种一致的主机地址格式消除了这个差异。每台主机会被分配至少一个互联网络地址（IP 地址），这个唯一地址标识了这台主机。

2. 传送机制。不同网络有不同的机制封装帧。互联网络协议通过定义一种把数据位捆扎成不连续的片（称为包）的统一方式来消除差异。一个包是由`包头`和`有效载荷`组成的。
   
   包头包含该包的信息：源地址、目的地址等。有效载荷包含数据位。

## 三、全球 IP 因特网

全球 IP 因特网是最著名和最成功的互联网络实现。每台因特网主机都运行着实现 TCP / IP 协议（传输控制协议 / 互联网络协议）。因特网的客户端和服务器混合使用套接字接口函数和 Unix I / O 函数来进行通信。TCP / IP 实际上是一个协议族，其中每一个都提供不同功能。     

从程序员的角度，因特网可以看作为一个世界范围的主机集合，满足以下特性：

* 主机集合被映射为一组 32 位的 IP 地址。

* 这组 IP 地址被映射为一组称为因特网域名的标识符。

* 因特网主机上的进程能够通过连接和其他因特网主机进行通信。

##### IP 地址

一个 IP 地址就是一个 32 位无符号整数，其结构如下：

```c
typedef uint32_t in_addr_t;

struct in_addr {
    in_addr_t s_addr;
};
```

由于因特网主机可以有不同的主机字节序，TCP / IP 定义了一个统一的网络字节顺序（大端字节顺序）。Unix 系统提供了一些函数供数据在网络和主机字节顺序间转换：

* `htol`, `htons`, `ntohl`, `ntohs`

##### 域名

因特网客户端与服务器间通过 IP 通信。但对于人来说长整数很难记忆，所以因特网也定义了一组域名，以及一种将域名映射到 IP 地址的机制。    

域名是一串用句点分割的单词。域名集合形成了一个层次结构：

* 根域名

* 一级域名

* 二级域名

* ...

因特网定义了域名集合与 IP 集合的映射。这个映射通过分布世界范围内的数据库（DNS）来维护的。

##### 因特网连接

因特网客户端和服务器通过在连接上发送和接收字节流来通信。从连接一对进程意义上而言，连接是*点对点* 的。从数据可以双向流动的角度说，它是*全双工*的。同时它也是可靠的。

一个套接字是链接的一个端点。每个套接字有相应的*套接字地址*，是由一个因特网地址和一个 16 位整数端口组成的，表示为“地址：端口”。    

当客户端发起连接请求时，内核会自动在客户端分配一个随机端口，称为*临时端口*，但服务器的端口通常是固定的。一个连接是由它两端的套接字地址唯一确定的。这对套接字地址叫做*套接字对*，由下列元组来表示：

```
(cliaddr:cliport, servaddr, servport)
```

## 四、套接字接口

套接字接口是一组函数，他们和 Unix I/O 函数结合起来，用以创建网络应用。

##### 套接字地址结构

从 Linux 内核角度看，一个套接字就是通信的一个端点；从程序的角度看，套接字就是一个有相应描述符的打开文件。在套接字编程中需要指定套接字地址作为参数，不同协议族有不同的地址结构定义方式。通常以 `sockaddr_` 开头，每一个协议族有唯一的后缀，对于以太网来说，其结构定义如下：

```c
struct sockaddr_in {
   sa_family_t    sin_family; /* address family: AF_INET */
   in_port_t      sin_port;   /* port in network byte order */
   struct in_addr sin_addr;   /* internet address */
};

struct sockaddr {
   sa_family_t sa_family;
   char        sa_data[14];
}
```

IP 和 端口号总是以网络字节顺序（大端顺序）存放。

###### 创建通信端点

客户端和服务器使用 `socket` 函数来创建一个*套接字描述符*：

```c
clientfd = socket(AF_INET, SOCK_STREAM, 0);
```

其中 `AF_INET` 表明使用 32 位 IP 地址，而 `SOCK_STREAM` 表示这个套接字是连接的一个端点。`socket` 函数返回的 *clientfd* 描述符仅是部分打开的，还不能用于读写。还需要使用 `connect` 函数建立与服务器的连接。

###### 在套接字上发起连接

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

`connect` 函数会试图与套接字地址为 `addr` 的服务器建立因特网连接，其中 `addrlen` 是 `sockaddr_in` 结构体大小。

`connect` 函数会阻塞，一直到成功建立连接或发生错误。如果成功 *clientid* 描述符就准备好可以读写了。得到的连接是由套接子对组成的。

```
(x:y, addr.sin_addr:addr.sin_port)
```

其中 x, y 分别为客户端的 IP 地址以及临时端口，它唯一的确定了客户端主机上的客户端进程。

##### 绑定套接字地址与描述符

```c
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

`bind` 函数告诉内核将 `addr` 中的服务器套接字地址和套接字描述符 `sockfd` 联系起来。

##### 监听套接字上的连接

```c
int listen(int sockfd, int backlog);
```

服务器是等待来自客户端的链接请求的被动实体。默认情况下，内核会认为 `socket` 函数创建的描述符对应于*主动套接字*，它存在于一个连接的客户端。服务器调用 `listen` 函数告诉内核，描述符是被服务器而不是客户端使用的。

`listen` 函数将 `sockfd` 从一个*主动套接字*转化为一个*监听套接字*，该套接字可以接受来自客户端的连接请求。

##### 接受套接字上的连接

```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

`accept` 函数等待来自客户端的连接请求到达*监听描述符*，并返回一个*已连接描述符*。



*监听描述符*和*已连接描述符区别*：

监听描述符作为客户端链接请求的一个端点，通常被创建一次，并存在于服务器整个生命周期。     

已连接描述符是客户端和服务器之前已经建立起来了的连接的一个端点。

------------

[^DMA]:  Direct Memory Access，即直接存储器访问。DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。
